/**
 * Shared utility functions for agent adapters.
 */

const fs = require('fs');
const path = require('path');
const os = require('os');
const crypto = require('crypto');

const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50 MB
const MAX_SCAN_FILES = 1000;

function expandHome(filepath) {
  if (!filepath) return filepath;
  if (filepath === '~') return os.homedir();
  if (filepath.startsWith('~/')) {
    return path.join(os.homedir(), filepath.slice(2));
  }
  return filepath;
}

function normalizePath(filepath) {
  return path.resolve(expandHome(filepath));
}

function hashPath(filepath) {
  return crypto.createHash('sha256').update(normalizePath(filepath)).digest('hex');
}

function collectMatchingFiles(dirPath, predicate, recursive = false) {
  if (!dirPath || !fs.existsSync(dirPath)) return [];

  const matches = [];

  function search(currentDir) {
    if (matches.length >= MAX_SCAN_FILES) return;

    let entries = [];
    try {
      entries = fs.readdirSync(currentDir, { withFileTypes: true });
    } catch (error) {
      return;
    }

    for (const entry of entries) {
      if (matches.length >= MAX_SCAN_FILES) return;

      const fullPath = path.join(currentDir, entry.name);
      // Skip symlinked directories by default (Phase 6)
      if (entry.isDirectory()) {
        if (entry.isSymbolicLink()) continue;
        if (recursive) search(fullPath);
        continue;
      }

      if (!predicate(fullPath, entry.name)) continue;

      try {
        // Prefer nanosecond precision to keep "latest" selection stable
        // across runtimes and filesystems.
        let mtimeNs;
        try {
          const statBig = fs.statSync(fullPath, { bigint: true });
          mtimeNs = statBig.mtimeNs;
        } catch (_error) {
          const stat = fs.statSync(fullPath);
          mtimeNs = BigInt(Math.trunc(stat.mtimeMs * 1e6));
        }
        matches.push({ path: fullPath, mtimeNs });
      } catch (error) {
        // Ignore entries that disappear while scanning.
      }
    }
  }

  search(dirPath);
  matches.sort((a, b) => {
    if (b.mtimeNs !== a.mtimeNs) {
      return b.mtimeNs > a.mtimeNs ? 1 : -1;
    }
    return String(a.path).localeCompare(String(b.path));
  });
  return matches;
}

function readJsonlLines(filePath) {
  const stat = fs.statSync(filePath);
  if (stat.size > MAX_FILE_SIZE) {
    throw new Error(`Skipped ${filePath} (exceeds ${MAX_FILE_SIZE / (1024 * 1024)}MB size limit)`);
  }
  return fs.readFileSync(filePath, 'utf-8').split('\n').filter(Boolean);
}

function findLatestByCwd(files, cwdExtractor, expectedCwd) {
  for (const file of files) {
    const fileCwd = cwdExtractor(file.path);
    if (fileCwd && fileCwd === expectedCwd) {
      return file.path;
    }
  }
  return null;
}

function getFileTimestamp(filePath) {
  try {
    const stat = fs.statSync(filePath);
    return stat.mtime.toISOString();
  } catch (error) {
    return null;
  }
}

function extractText(value) {
  if (typeof value === 'string') return value;
  if (!Array.isArray(value)) return '';

  return value
    .map(part => {
      if (typeof part === 'string') return part;
      if (part && typeof part.text === 'string') return part.text;
      return '';
    })
    .join('');
}

function extractClaudeText(value) {
  if (typeof value === 'string') return value;
  if (!Array.isArray(value)) return '';

  return value
    .filter(part => part && part.type === 'text')
    .map(part => part.text || '')
    .join('');
}

function redactSensitiveText(input) {
  let output = String(input || '');
  // OpenAI keys (sk-proj-, sk-ant-, sk-...) with hyphens allowed
  output = output.replace(/\bsk-[A-Za-z0-9_-]{20,}/g, 'sk-[REDACTED]');
  // AWS access keys
  output = output.replace(/\bAKIA[0-9A-Z]{16}\b/g, 'AKIA[REDACTED]');
  // GitHub tokens
  output = output.replace(/\b(ghp_|gho_|ghs_|ghr_)[A-Za-z0-9_]{20,}/g, '$1[REDACTED]');
  output = output.replace(/\bgithub_pat_[A-Za-z0-9_]{20,}/g, 'github_pat_[REDACTED]');
  // Google API keys
  output = output.replace(/\bAIza[A-Za-z0-9_-]{20,}/g, 'AIza[REDACTED]');
  // Slack tokens
  output = output.replace(/\b(xoxb-|xoxp-|xoxs-)[A-Za-z0-9-]{10,}/g, '$1[REDACTED]');
  // Bearer tokens
  output = output.replace(/\bBearer\s+[A-Za-z0-9._-]{10,}/gi, 'Bearer [REDACTED]');
  // JWT-like tokens (three base64url segments)
  output = output.replace(/\beyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}/g, '[REDACTED_JWT]');
  // PEM private keys
  output = output.replace(/-----BEGIN\s+(RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----[\s\S]*?-----END\s+(RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----/g, '[REDACTED_PEM_KEY]');
  // Connection strings â€” redact userinfo portion
  output = output.replace(/((?:postgres|mysql|mongodb|redis|amqp):\/\/)[^\s"']+/gi, '$1[REDACTED]');
  // Secret assignments (api_key, api-key, apikey, token, secret, password)
  output = output.replace(
    /\b(api[_-]?key|token|secret|password)\b\s*[:=]\s*["']?[^"'\s]+["']?/gi,
    (_, key) => `${key}=[REDACTED]`
  );
  return output;
}

module.exports = {
  MAX_FILE_SIZE,
  MAX_SCAN_FILES,
  expandHome,
  normalizePath,
  hashPath,
  collectMatchingFiles,
  readJsonlLines,
  findLatestByCwd,
  getFileTimestamp,
  extractText,
  extractClaudeText,
  redactSensitiveText,
};
